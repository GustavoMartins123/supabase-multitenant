-- 1ï¸âƒ£ Ver logs em tempo real (Ãºltimos 20)
SELECT 
    to_char(timestamp, 'YYYY-MM-DD HH24:MI:SS') as quando,
    container_name,
    stream,
    LEFT(message, 100) as mensagem
FROM public.logs 
ORDER BY timestamp DESC 
LIMIT 20;

-- 2ï¸âƒ£ Top containers mais tagarelas (Ãºltimas 24h)
SELECT 
    container_name,
    COUNT(*) as total_logs,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as percentual
FROM public.logs
WHERE timestamp > NOW() - INTERVAL '24 hours'
GROUP BY container_name
ORDER BY total_logs DESC;

-- 3ï¸âƒ£ Buscar erros recentes (Ãºltima hora)
SELECT 
    to_char(timestamp, 'HH24:MI:SS') as hora,
    container_name,
    message
FROM public.logs
WHERE (message ILIKE '%error%' OR message ILIKE '%fail%' OR message ILIKE '%exception%')
  AND timestamp > NOW() - INTERVAL '1 hour'
ORDER BY timestamp DESC
LIMIT 50;

-- 4ï¸âƒ£ DistribuiÃ§Ã£o de logs por hora do dia (Ãºltimas 24h)
SELECT 
    EXTRACT(HOUR FROM timestamp) as hora,
    COUNT(*) as total,
    LPAD('â–ˆ', (COUNT(*) * 50 / MAX(COUNT(*)) OVER())::int, 'â–ˆ') as grafico
FROM public.logs
WHERE timestamp > NOW() - INTERVAL '24 hours'
GROUP BY hora
ORDER BY hora;

-- 5ï¸âƒ£ Ver todas as partiÃ§Ãµes existentes
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as tamanho
FROM pg_tables
WHERE tablename LIKE 'logs_%'
  AND schemaname = 'public'
ORDER BY tablename DESC;

-- 6ï¸âƒ£ Logs por container em tempo real (streaming)
-- Execute com \watch 1 no psql para atualizar a cada segundo
SELECT 
    container_name,
    COUNT(*) as logs_last_minute
FROM public.logs
WHERE timestamp > NOW() - INTERVAL '1 minute'
GROUP BY container_name
ORDER BY logs_last_minute DESC;
-- No psql: \watch 1

-- 7ï¸âƒ£ Procurar por container especÃ­fico (Ãºltimas 100 linhas)
SELECT 
    to_char(timestamp, 'HH24:MI:SS.MS') as hora,
    stream,
    message
FROM public.logs
WHERE container_name = 'nome-do-container'  -- â† TROQUE AQUI
ORDER BY timestamp DESC
LIMIT 100;

-- 8ï¸âƒ£ EstatÃ­sticas gerais do banco
SELECT 
    (SELECT COUNT(*) FROM public.logs) as total_logs,
    (SELECT COUNT(DISTINCT container_name) FROM public.logs) as containers_unicos,
    (SELECT MIN(timestamp) FROM public.logs) as log_mais_antigo,
    (SELECT MAX(timestamp) FROM public.logs) as log_mais_recente,
    pg_size_pretty(pg_database_size('logs_db')) as tamanho_total_db;


-- 9ï¸âƒ£ Ver status do cron job de manutenÃ§Ã£o
\c postgres
SELECT 
    jobname,
    schedule,
    active,
    database
FROM cron.job
WHERE jobname = 'maintain_logs_partitions_job';

-- ðŸ”Ÿ Ver histÃ³rico de execuÃ§Ãµes do cron (Ãºltimas 10)
SELECT 
    jobid,
    runid,
    status,
    return_message,
    start_time,
    end_time
FROM cron.job_run_details
WHERE jobname = 'maintain_logs_partitions_job'
ORDER BY start_time DESC
LIMIT 10;

-- 1ï¸âƒ£1ï¸âƒ£ ForÃ§ar execuÃ§Ã£o manual da manutenÃ§Ã£o de partiÃ§Ãµes
\c logs_db
SELECT maintain_log_partitions();

-- 1ï¸âƒ£2ï¸âƒ£ Ver quantos logs tem em cada partiÃ§Ã£o
SELECT 
    tableoid::regclass as particao,
    COUNT(*) as total_logs,
    MIN(timestamp) as primeiro_log,
    MAX(timestamp) as ultimo_log,
    pg_size_pretty(pg_total_relation_size(tableoid)) as tamanho
FROM public.logs
GROUP BY tableoid
ORDER BY particao DESC;

-- 1ï¸âƒ£3ï¸âƒ£ Testar inserÃ§Ã£o de log (pra ver se tÃ¡ funcionando)
\c logs_db
INSERT INTO public.logs (
    timestamp, 
    container_name, 
    message, 
    stream
) VALUES (
    NOW(), 
    'teste-container', 
    'Mensagem de teste - deletar depois!', 
    'stdout'
);

-- 1ï¸âƒ£4ï¸âƒ£ Limpar logs de teste
DELETE FROM public.logs 
WHERE container_name = 'teste-container' 
  AND message LIKE '%teste%';


-- 1ï¸âƒ£5ï¸âƒ£ Taxa de logs por minuto (Ãºltimas 2 horas)
SELECT 
    date_trunc('minute', timestamp) as minuto,
    COUNT(*) as logs_por_minuto
FROM public.logs
WHERE timestamp > NOW() - INTERVAL '2 hours'
GROUP BY minuto
ORDER BY minuto DESC
LIMIT 20;

-- 1ï¸âƒ£6ï¸âƒ£ Containers que mais logam erros (Ãºltimas 24h)
SELECT 
    container_name,
    COUNT(*) as total_erros,
    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM public.logs 
                                WHERE timestamp > NOW() - INTERVAL '24 hours'), 2) as percentual
FROM public.logs
WHERE (message ILIKE '%error%' OR message ILIKE '%fail%')
  AND timestamp > NOW() - INTERVAL '24 hours'
GROUP BY container_name
ORDER BY total_erros DESC;

-- 1ï¸âƒ£7ï¸âƒ£ Comparar volume de logs por perÃ­odo
WITH stats AS (
    SELECT 
        'Ãšltima Hora' as periodo,
        COUNT(*) as total
    FROM public.logs 
    WHERE timestamp > NOW() - INTERVAL '1 hour'
    UNION ALL
    SELECT 
        'Ãšltimas 24h',
        COUNT(*)
    FROM public.logs 
    WHERE timestamp > NOW() - INTERVAL '24 hours'
    UNION ALL
    SELECT 
        'Ãšltima Semana',
        COUNT(*)
    FROM public.logs 
    WHERE timestamp > NOW() - INTERVAL '7 days'
)
SELECT 
    periodo,
    total,
    pg_size_pretty(total * 500) as tamanho_estimado  -- ~500 bytes por log
FROM stats;