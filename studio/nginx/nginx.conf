env FERNET_SECRET;
env NGINX_SHARED_TOKEN;
env COOKIE_SIGN_SECRET;
env SERVER_DOMAIN;
env BACKEND_PROTO;
worker_processes auto;
events {
    worker_connections 2048;
}
http{
    include       mime.types;
    default_type  application/octet-stream;
    
    sendfile        on;
    keepalive_timeout  65;

    lua_package_path "/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;;";


    resolver 127.0.0.11 valid=30s;
    map_hash_bucket_size 256;
                       
    lua_shared_dict service_keys  10m;
    lua_shared_dict users_cache 5m;

    map "" $authelia_upstream { default "authelia:9091"; }

    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    map $scheme $hsts_header {
    https   "max-age=63072000; preload";
    }

    init_worker_by_lua_block {
        local lyaml = require "lyaml"
        local resty_sha2 = require "resty.sha256"
        local str = require "resty.string"
        local lfs = require "lfs"
        local cache = ngx.shared.users_cache
        local yaml = "/config/users_database.yml"
        
        local function load_users()
            local f = assert(io.open(yaml))
            local t = lyaml.load(f:read("*a")); f:close()
            cache:flush_all()
            ngx.log(ngx.INFO, "Carregando usuários do arquivo YAML…")
            
            for uname, attr in pairs(t.users or {}) do
                local groups = attr.groups or {}
                local is_active = false
                local is_admin = false
                
                -- Verificar se é ativo e se é admin
                for _, group in ipairs(groups) do
                    if group == "active" then
                        is_active = true
                    elseif group == "admin" then
                        is_admin = true
                    end
                end
                
                local email = (attr.email or ""):lower():gsub("%s+", "")
                local display_name = attr.displayname or uname
                local hasher = resty_sha2:new()
                hasher:update(email)
                local digest = hasher:final()
                local hash = str.to_hex(digest)
                local cjson = require "cjson.safe"
                
                if is_active then
                    cache:set(hash, cjson.encode({
                        email = email,
                        display_name = display_name,
                        username = uname,
                        is_active = true,
                        is_admin = is_admin
                    }))
                    ngx.log(ngx.INFO, "Usuário ATIVO carregado: " .. uname .. " (" .. email .. ") - Admin: " .. tostring(is_admin))
                else
                    cache:set(hash, cjson.encode({
                        email = email,
                        display_name = display_name .. " (INATIVO)",
                        username = uname,
                        is_active = false,
                        is_admin = is_admin 
                    }))
                    ngx.log(ngx.INFO, "Usuário INATIVO mantido no cache: " .. uname .. " (" .. email .. ") - Admin: " .. tostring(is_admin))
                end
                
                ngx.log(ngx.INFO, "[CACHE] set() – user=", uname,
                    " email=", email,
                    " hash=", hash,
                    " active=", is_active,
                    " admin=", is_admin)
            end
            
            cache:set("__mtime", lfs.attributes(yaml, "modification"))
            ngx.log(ngx.INFO, "[CACHE] Cache atualizado em mtime=", cache:get("__mtime"))
        end
        
        load_users()
        
        local keys, err = cache:get_keys(0)
        if keys then
            ngx.log(ngx.INFO, "[CACHE] total keys loaded: ", #keys)
        else
            ngx.log(ngx.INFO, "[CACHE] get_keys error: ", err)
        end
        
        ngx.timer.every(10, function()
            local m = lfs.attributes(yaml, "modification")
            if cache:get("__mtime") ~= m then
                ngx.log(ngx.INFO, "[CACHE] Detected YAML change (old=", cache:get("__mtime"),
                    " new=", m, "), recarregando…")
                load_users()
            end
        end)
    }


    init_by_lua_block {
        COOKIE_SECRET = os.getenv("COOKIE_SIGN_SECRET")
    }
    server {
        listen 443 ssl;
        server_name pass;

        ssl_certificate /config/ssl/ca.pem;
        ssl_certificate_key /config/ssl/ca.key;

        auth_request /authelia;
        auth_request_set $target_url $scheme://$http_host$request_uri;
        auth_request_set $authelia_redirect $upstream_http_location;
        error_page 401 =302 $authelia_redirect;


        access_log /var/log/studio_access.log;
        error_log /var/log/studio_error.log debug;
        root /usr/share/nginx/html;
        index index.html;
 
        set_by_lua_block $server_domain {
            return os.getenv("SERVER_DOMAIN")
        }
        set_by_lua_block $server_hostname {
            local full_url = ngx.var.server_domain
            
            if not full_url or full_url == "" then
                return "" 
            end

            local hostname = string.match(full_url, "https?://([^/:]+)")
            
            return hostname or full_url
        }

        set_by_lua_block $upstream_scheme {
            local proto = os.getenv("BACKEND_PROTO")
            if proto == "https" then
                return "https"
            end
            return "http"
        }
        location = /set-project {
            content_by_lua_block {
                local hmac  = require "resty.hmac"
                local str   = require "resty.string"
                local key = COOKIE_SECRET
                local ref = ngx.var.arg_ref
                if not ref or ref == "" then return ngx.exit(400) end

                local ts  = tostring(ngx.time())
                local mac = hmac:new(key, hmac.ALGOS.SHA256)
                local sig = str.to_hex(mac:final(ref.."."..ts))

                ngx.header["Set-Cookie"] =
                    ("supabase_project=%s.%s.%s; Path=/; HttpOnly; SameSite=Lax; Max-Age=86400")
                    :format(ref, ts, sig)

                ngx.say("ok")
            }
        }

        set_by_lua_block $project_ref {
            local cookie = ngx.var.cookie_supabase_project
            if not cookie then return "default" end

            local str     = require "resty.string"
            local hmac    = require "resty.hmac"
            local key     = COOKIE_SECRET

            local ref, ts, sig = cookie:match("^([^%.]+)%.(%d+)%.([0-9a-f]+)$")
            if not ref then return "default" end
            if (ngx.time() - tonumber(ts)) > 86400 then   -- expirou
                return "default"
            end
            local mac = hmac:new(key, hmac.ALGOS.SHA256)
            local expect = str.to_hex( mac:final(ref.."."..ts) )
            if string.lower(expect) ~= string.lower(sig) then
                ngx.log(ngx.ERR, "Assinatura de cookie inválida para projeto: ", ref)
                return ngx.exit(403)
            end
            return ref
        }


        set_by_lua_block $server_path {
            local ref = ngx.var.cookie_supabase_session_project or "default"
            return ngx.var.server_domain .. "/" .. ngx.var.project_ref .. "/"
        }
        ## Flutter Web
        location / {
            try_files $uri $uri/ /index.html; 
        }
        location /authelia {
            internal;
            proxy_pass https://$authelia_upstream/api/verify;
            proxy_set_header X-Original-URL $scheme://$http_host$request_uri;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-Method $request_method;
            proxy_set_header X-Forwarded-For $remote_addr;
            proxy_set_header Content-Length "";
            proxy_pass_request_body off;
            proxy_ssl_server_name on;
            proxy_ssl_verify on;
            proxy_ssl_trusted_certificate /config/ssl/ca.pem;
        }

        location ^~ /_next/          { 
            auth_request off; 
            proxy_pass http://studio:3000; 
        }
        location ^~ /monaco-editor/  { proxy_pass http://studio:3000; }
        location ^~ /favicon/        { 
            auth_request off;
            proxy_pass http://studio:3000;
        }
        location ^~ /img/            {
            auth_request off;
            proxy_pass http://studio:3000; 
        }

        location ~ ^/api/platform/projects/[^/]+/run-lints$ {
            default_type application/json;
            add_header   Cache-Control "no-store";
            return 200 '[]';
        }

        location ~ ^/api/platform/projects/default/api/rest(.*)$ {
            access_by_lua_block {
                local ref = ngx.var.project_ref
                if not ref or ref == "default" then
                    return
                end
                -- faz fetch da chave (pode abrir socket)
                local get = require "get_service_key"
                local key = get(ref)
                if key and key ~= "" then
                    ngx.req.set_header("Authorization", "Bearer " .. key)
                    ngx.req.set_header("apikey", key)
                end
            }
            rewrite_by_lua_block {
                local rest_path = ngx.var[1] or ""    -- captura do regex
                rest_path = rest_path:gsub("^/", "")  -- tira barra extra
                ngx.req.set_uri("rest/v1/" .. rest_path, false)
            }
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_set_header X-Real-IP          $remote_addr;
            proxy_set_header X-Forwarded-Proto  $scheme;
            proxy_set_header X-Forwarded-For    $remote_addr;
            proxy_http_version 1.1;

            proxy_pass $server_path$uri;             
        }

        location ~ ^/api/v1/projects/ {
            proxy_pass http://studio:3000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location ~* ^/api/platform/projects/ {
            proxy_pass http://studio:3000;
            proxy_redirect off;
        }

        location ^~ /project/ {
            proxy_pass http://studio:3000;
        }
        location ~ ^/_internal_api/projects/(?<slug>[^/]+)/members$ {
            internal;
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_pass $server_domain/api/projects/$slug/members;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        location ~ ^/api/projects/(?<slug>[^/]+)/members/(?<member_id>[^/]+)$ {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;

            access_by_lua_block {
                local email = ngx.var.authelia_email
                if not email or email == "" then
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
                local sha256 = require "resty.sha256"
                local str    = require "resty.string"
                local h      = sha256:new(); h:update(email)
                local email_hash = str.to_hex(h:final())
                ngx.req.set_header("Remote-Email",  email_hash)
                ngx.req.set_header("Remote-Groups", ngx.var.authelia_groups or "")
            }
            if ($request_method != DELETE) {
                return 405;
            }
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_pass $server_domain/api/projects/$slug/members/$member_id;
        }
        
        location = /api/projects/duplicate {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;
            
            access_by_lua_block {
            -- Verifica autenticação
            local email = ngx.var.authelia_email
            if not email or email == "" then
                ngx.log(ngx.ERR, "[DUPLICATE] Email não disponível para hashing.")
                return ngx.exit(ngx.HTTP_UNAUTHORIZED)
            end
            
            -- Gera hash SHA256 do email
            local sha256 = require "resty.sha256"
            local str    = require "resty.string"
            local hasher = sha256:new()
            hasher:update(email)
            local digest = hasher:final()
            local email_hash = str.to_hex(digest)
            
            ngx.log(ngx.INFO, "[DUPLICATE] Hash de email gerado para duplicação de projeto")
            
            -- Injeta headers necessários para a API Python
            ngx.req.set_header("Remote-Email", email_hash)
            ngx.req.set_header("Remote-Groups", ngx.var.authelia_groups or "")
            }
            

            if ($request_method != "POST") {
                return 405;
            }
            
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_pass $server_domain/api/projects/duplicate;
            proxy_set_header X-Real-IP          $remote_addr;
            proxy_set_header X-Forwarded-Proto  $scheme;
            proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
        }
        
        
        location ~ ^/api/projects/(?<slug>[^/]+)/members$ {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups $upstream_http_remote_groups;
            access_by_lua_block {
                local email = ngx.var.authelia_email
                if not email or email == "" then
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
                local sha256 = require "resty.sha256"
                local str    = require "resty.string"
                local h      = sha256:new(); h:update(email)
                local email_hash = str.to_hex(h:final())
                ngx.req.set_header("Remote-Email",  email_hash)
                ngx.req.set_header("Remote-Groups", ngx.var.authelia_groups or "")
            }

            if ($request_method = "GET"){
                content_by_lua_block {
                    local cjson  = require "cjson.safe"
                    local cache  = ngx.shared.users_cache
                    local uri    = "/_internal_api/projects/" .. ngx.var.slug .. "/members"

                    local res = ngx.location.capture(uri, { method = ngx.HTTP_GET })
                    if res.status ~= 200 then return ngx.exit(res.status) end
                    local members = cjson.decode(res.body) or {}

                    -- Enriquece com dados do cache e marca status
                    for _, m in ipairs(members) do
                        local ud_json = cache:get(m.user_id)
                        if ud_json then
                            local ud = cjson.decode(ud_json)
                            m.display_name = ud.display_name
                            m.username = ud.username
                            m.is_active = ud.is_active
                            m.status = ud.is_active and "active" or "inactive"
                        else
                            -- Usuário não encontrado no cache (removido completamente)
                            m.display_name = "Usuário Removido"
                            m.username = "unknown"
                            m.is_active = false
                            m.status = "removed"
                        end
                    end

                    ngx.header.content_type = "application/json"
                    ngx.say(cjson.encode(members))
                }
            }
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            if ($request_method = "POST") {
                proxy_pass $server_domain/api/projects/$slug/members;
            }
        }
        location ~ ^/api/projects/(?<slug>[^/]+)/available-users$ {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups $upstream_http_remote_groups;

            access_by_lua_block {

                local email = ngx.var.authelia_email
                if not email or email == "" then
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end

                local sha256 = require "resty.sha256"
                local str = require "resty.string"
                local hasher = sha256:new()
                hasher:update(email)
                local digest = hasher:final()
                local email_hash = str.to_hex(digest)

                ngx.req.set_header("Remote-Email", email_hash)
                ngx.req.set_header("Remote-Groups", ngx.var.authelia_groups or "")
            }

            # 2) Conteúdo em Lua: fetch de membros + cache
            content_by_lua_block {

                local cjson = require "cjson.safe"
               local slug  = ngx.var.slug

                if not slug or slug == "" then
                    ngx.log(ngx.ERR, "[AVAILABLE][CONTENT] Slug inválido, retornando 400")
                    return ngx.exit(400)
                end

                -- 2.1) Busca membros atuais da API
                local res = ngx.location.capture("/_internal_api/projects/" .. slug .. "/members")

                if res.status ~= 200 then
                    ngx.log(ngx.ERR, "[AVAILABLE][CONTENT] Erro no fetch de membros, status ", res.status)
                    return ngx.exit(res.status)
                end

                local current = cjson.decode(res.body) or {}
                local used = {}
                for _, m in ipairs(current) do
                    if m.user_id then
                        used[m.user_id] = true
                    end
                end

                -- 2.2) Filtra cache de usuários
                local cache = ngx.shared.users_cache
                local keys, err = cache:get_keys(0)
                if not keys then
                    ngx.log(ngx.ERR, "[AVAILABLE][CONTENT] cache:get_keys error: ", err)
                    return ngx.exit(500)
                end
                ngx.log(ngx.ERR, "[AVAILABLE][CONTENT] Cache keys count: ", #keys)

                local available = {}
                for _, h in ipairs(keys) do
                    if h ~= "__mtime" and not used[h] then
                        local ud_json = cache:get(h)
                        if ud_json then
                            local ud = cjson.decode(ud_json)
                            -- APENAS USUÁRIOS ATIVOS FICAM DISPONÍVEIS
                            if ud.is_active then
                                ngx.log(ngx.ERR, "[AVAILABLE][CONTENT] Adding available user: ", h)
                                table.insert(available, { 
                                    user_id = h, 
                                    display_name = ud.display_name,
                                    username = ud.username,
                                    status = "active"
                                })
                            end
                        end
                    end
                end

                local json_response = cjson.encode(available)
                ngx.log(ngx.ERR, "[AVAILABLE][CONTENT] JSON final: ", json_response)
                ngx.header.content_type = "application/json"
                ngx.say(json_response)
            }
        }
        location ~ ^/api/projects/(?<slug>[^/]+)/status$ {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;

            access_by_lua_block {
                local email = ngx.var.authelia_email
                if not email or email == "" then
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
                local sha256 = require "resty.sha256"
                local str    = require "resty.string"
                local h      = sha256:new(); h:update(email)
                ngx.req.set_header("Remote-Email",  str.to_hex(h:final()))
                ngx.req.set_header("Remote-Groups", ngx.var.authelia_groups or "")
            }

            if ($request_method != "GET") { return 405; }
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_pass $server_domain/api/projects/$slug/status;
        }
        location ~ ^/api/projects/(?<slug>[^/]+)/logs/(?<service>[^/]+)$ {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;

            access_by_lua_block {
                local email = ngx.var.authelia_email
                if not email or email == "" then
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
                local sha256 = require "resty.sha256"
                local str    = require "resty.string"
                local h      = sha256:new(); h:update(email)
                ngx.req.set_header("Remote-Email",  str.to_hex(h:final()))
                ngx.req.set_header("Remote-Groups", ngx.var.authelia_groups or "")
            }
            if ($request_method != "GET") { return 405; }
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_pass $server_domain/api/projects/$slug/logs/$service$is_args$args;
        }

        location ~ ^/api/projects/(?<slug>[^/]+)/start$ {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;

            access_by_lua_block {
                local email = ngx.var.authelia_email
                if not email or email == "" then
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
                local sha256 = require "resty.sha256"
                local str    = require "resty.string"
                local h      = sha256:new(); h:update(email)
                ngx.req.set_header("Remote-Email",  str.to_hex(h:final()))
                ngx.req.set_header("Remote-Groups", ngx.var.authelia_groups or "")
            }

            if ($request_method != "POST") { return 405; }
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_pass $server_domain/api/projects/$slug/start;
        }

        location ~ ^/api/projects/(?<slug>[^/]+)/stop$ {       
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;

            access_by_lua_block {
                local email = ngx.var.authelia_email
                if not email or email == "" then
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
                local sha256 = require "resty.sha256"
                local str    = require "resty.string"
                local h      = sha256:new(); h:update(email)
                ngx.req.set_header("Remote-Email",  str.to_hex(h:final()))
                ngx.req.set_header("Remote-Groups", ngx.var.authelia_groups or "")
            }

            if ($request_method != "POST") { return 405; }
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_pass $server_domain/api/projects/$slug/stop;
        }

        location ~ ^/api/projects/(?<slug>[^/]+)/restart$ { 
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;

            access_by_lua_block {
                local email = ngx.var.authelia_email
                if not email or email == "" then
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
                local sha256 = require "resty.sha256"
                local str    = require "resty.string"
                local h      = sha256:new(); h:update(email)
                ngx.req.set_header("Remote-Email",  str.to_hex(h:final()))
                ngx.req.set_header("Remote-Groups", ngx.var.authelia_groups or "")
            }

            if ($request_method != "POST") { return 405; }
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_pass $server_domain/api/projects/$slug/restart;
        }


        location ~ ^/api/projects(/.*)?$ {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups $upstream_http_remote_groups;
            access_by_lua_block {
                local email = ngx.var.authelia_email
                if not email or email == "" then
                    ngx.log(ngx.ERR, "Email não disponível para hashing.")
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end

                local sha256 = require "resty.sha256"
                local str = require "resty.string"
                local hasher = sha256:new()
                hasher:update(email)
                local digest = hasher:final()
                local email_hash = str.to_hex(digest)
                ngx.log(ngx.INFO, "Hash de email gerado para a rota /api/projects")

                ngx.req.set_header("Remote-Email", email_hash)
                ngx.req.set_header("Remote-Groups", ngx.var.authelia_groups or "")
            }

            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_pass $server_domain/api/projects$1;
            proxy_set_header X-Real-IP        $remote_addr;
            proxy_set_header X-Forwarded-Proto $scheme; 
        }
        
        location = /api/platform/profile{
            proxy_set_header Host $host;
            proxy_set_header X-Forwarded-Scheme $scheme;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-For $remote_addr;
            proxy_set_header X-Real-IP $remote_addr;

            proxy_pass http://studio:3000;

            
            proxy_set_header Connection $http_connection;
            proxy_http_version 1.1;
        }



        location = /project/default {
            proxy_set_header Host $host;
            proxy_set_header X-Forwarded-Scheme $scheme;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-For $remote_addr;
            proxy_set_header X-Real-IP $remote_addr;

            proxy_pass http://studio:3000;

            
            proxy_set_header Connection $http_connection;
            proxy_http_version 1.1;
        }
                     
        location ~ ^/api/platform/pg-meta/([^/]+)(/.*)?$ {
            if ($request_method = OPTIONS) {
                add_header 'Access-Control-Allow-Origin'  '*'        always;
                add_header 'Access-Control-Allow-Methods' 'GET, OPTIONS' always;
                add_header 'Access-Control-Allow-Headers' 'Authorization, Content-Type' always;
                return 204;
            }
            set $resource $2;                 # /tables  | /columns/1 …
            set_by_lua_block $project_ref {
                local sid = ngx.var.cookie_supabase_session
                if not sid then return "default" end
                return ngx.shared.session_to_project:get(sid) or "default"
            }
            access_by_lua_block {
                local ref = ngx.var.project_ref
                if not ref or ref == "default" then
                    return
                end
                -- faz fetch da chave (pode abrir socket)
                local get = require "get_service_key"
                local key = get(ref)
                if key and key ~= "" then
                    ngx.req.set_header("apikey", key)
                end
            }
            rewrite_by_lua_block {
                local method = ngx.req.get_method()

                ngx.req.read_body()
                local data = ngx.req.get_body_data()
                local cjson = require "cjson.safe"


                local uri    = ngx.var.request_uri  -- inclui path + query
                -- bate exatamente contra o pattern
                if method == "GET"
                    and uri:match("^/api/platform/pg%-meta/default/policies%?included_schemas=&excluded_schemas=$")
                then
                    -- reescreve para /policies sem query
                    ngx.req.set_uri("/policies", false)
                    ngx.req.set_uri_args({})
                    return
                end

                local function convert_fields(obj)
                    if type(obj) ~= "table" then
                        return obj
                    end
                    
                    -- Mapeamento de campos camelCase para snake_case
                    local mappings = {
                        tableId = "table_id",
                        defaultValue = "default_value",
                        defaultValueFormat = "default_value_format",
                        isNullable = "is_nullable",
                        isUnique = "is_unique",
                        isGenerated = "is_generated",
                        isIdentity = "is_identity",



                        dataType             = "data_type",
                        ordinalPosition      = "ordinal_position",
                        identityGeneration   = "identity_generation",
                        isUpdatable          = "is_updatable",
                        dropDefault         = "drop_default",
                    }
                    
                    for camel, snake in pairs(mappings) do
                        if obj[camel] ~= nil then
                            obj[snake] = obj[camel]
                            obj[camel] = nil
                        end
                    end
                    
                    -- Processa recursivamente para objetos aninhados
                    for k, v in pairs(obj) do
                        if type(v) == "table" then
                            obj[k] = convert_fields(v)
                        end
                    end
                    
                    return obj
                end

                ngx.req.read_body()
                local data = ngx.req.get_body_data()
                if data and #data > 0 then
                    local cjson = require "cjson.safe"
                    local success, js = pcall(cjson.decode, data)
                    if success and js then
                        -- Converte campos camelCase para snake_case
                        js = convert_fields(js)
                        ngx.req.set_body_data(cjson.encode(js))
                    else
                        ngx.log(ngx.WARN, "Falha ao processar JSON: ", (js or "formato inválido"))
                    end
                end

                local args = ngx.req.get_uri_args()
                local id = args["id"]
                local keys
                if id then
                    -- Remove o parâmetro 'id' da query string
                    args["id"] = nil
                    
                    -- Obtém o project_ref da variável Nginx
                    local project_ref = ngx.var.project_ref
                    
                    -- Constrói a nova URL sem o parâmetro 'id'
                    local resource = ngx.var.resource
                    
                    -- Adiciona o ID ao resource para o formato correto
                    if not resource:match("/$") then
                        resource = resource .. "/"
                    end
                    resource = resource .. id
                    
                    -- Atualiza a variável $resource para uso no proxy_pass
                    ngx.var.resource = resource
                    
                    -- Define os novos argumentos de URI (sem o parâmetro id)
                    ngx.req.set_uri_args(args)
                    
                    -- Continuamos o processamento para que o proxy_pass pegue a URI atualizada
                    ngx.log(ngx.INFO, "URI atualizada: resource=" .. resource)
                end

            }
            proxy_pass "${server_path}meta${resource}${is_args}${args}";
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_set_header X-Real-IP         $remote_addr;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        
        location /api/platform/auth {
            access_by_lua_block {
                local ref = ngx.var.project_ref
                if not ref or ref == "default" then
                    return
                end
                -- faz fetch da chave (pode abrir socket)
                local get = require "get_service_key"
                local key = get(ref)
                if key and key ~= "" then
                    ngx.req.set_header("Authorization", "Bearer " .. key)
                    ngx.req.set_header("apikey", key)
                end



                local proj = ngx.var.project_ref
                local method = ngx.var.request_method
                local uri = ngx.var.uri
                local user_id = uri:match("^/api/platform/auth/default/users/(.+)$")

                if method == "POST" and not user_id then
                    ngx.req.set_uri("auth/v1/signup", false)
                elseif method == "DELETE" and user_id then
                    ngx.req.set_uri("auth/v1/admin/users/" .. user_id, false)
                elseif method == "PATCH" and user_id then
                    ngx.req.set_uri("auth/v1/admin/users/" .. user_id, false)
                    ngx.req.set_method(ngx.HTTP_PUT)
                else
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say("Requisição inválida para " .. method .. " em " .. uri)
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
            }
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_set_header X-Forwarded-Scheme $scheme;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-For $remote_addr;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_pass $server_path$uri$is_args$args;

            
            proxy_set_header Connection $http_connection;
            proxy_http_version 1.1;
        }
        

        location /api/platform/storage {
            client_max_body_size 500M;
            access_by_lua_block {
                local ref = ngx.var.project_ref
                if not ref or ref == "default" then
                    return
                end
                -- faz fetch da chave (pode abrir socket)
                local get = require "get_service_key"
                local key = get(ref)
                if key and key ~= "" then
                    ngx.req.set_header("Authorization", "Bearer " .. key)
                    ngx.req.set_header("apikey", key)
		            ngx.ctx.service_key = key
                end
            }
            rewrite ^/api/platform/storage/default/buckets$ /storage/v1/bucket break;
            rewrite ^/api/platform/storage/default/buckets/([a-zA-Z0-9]+)$ /storage/v1/bucket/$1 break;
            rewrite ^/api/platform/storage/default/buckets/([a-zA-Z0-9]+)/empty$ /storage/v1/bucket/$1/empty break;
            rewrite ^/api/platform/storage/default/buckets/([a-zA-Z0-9_-]+)/objects/sign$  /storage/v1/object/sign/$1  break;
            rewrite ^/api/platform/storage/default/buckets/([a-zA-Z0-9]+)/objects/list$ /storage/v1/object/list/$1 break;
            rewrite ^/api/platform/storage/default/buckets/([a-zA-Z0-9_-]+)/objects/move$ /storage/v1/object/move/$1 break;
            rewrite ^/api/platform/storage/default/buckets/([a-zA-Z0-9_-]+)/objects/download$ /storage/v1/object/$1 break;
            rewrite ^/api/platform/storage/default/buckets/([a-zA-Z0-9_-]+)/objects$ /storage/v1/object/$1 break;
            rewrite_by_lua_block {
                local storage_prefix = "/storage/v1"
                local path = ngx.re.sub(ngx.var.uri, "^" .. storage_prefix, "", "jo")
                ngx.req.read_body()
                local data = ngx.req.get_body_data()

                if data then
                    local cjson = require "cjson"
                    local success, body = pcall(cjson.decode, data)
                    if success and body then
                        if ngx.var.request_method == "POST" and path == "/bucket" then
                            if body.id then
                                body.name = body.id
                                body.id = nil
                            end
                        end
                        if ngx.var.request_method == "POST" and ngx.re.match(path, "^/object/list/") then
                            if body.path then
                                body.prefix = body.path
                                body.path = nil
                            end
                        end
                        if ngx.var.request_method == "DELETE" and ngx.re.match(path, "^/object/[a-zA-Z0-9_-]+$") then
                            if body.paths then
                                body.prefixes = body.paths
                                body.paths = nil
                            end
                        end
                        if ngx.var.request_method == "POST" and ngx.re.match(path, "^/object/sign/") then
                            if body.path then
                            	local clean_path = ngx.re.gsub(body.path, "^/", "", "jo")
                            	body.paths = { clean_path }
                            	body.path = nil
                            end
                        end       
                        -- Para atualizar uma bucket existente, pois o storage espera um 'put' e não um patch 'https://supabase.github.io/storage/#/'
                        if ngx.var.request_method == "PATCH" and ngx.re.match(path, "^/bucket/[a-zA-Z0-9]+$") then
                            ngx.req.set_method(ngx.HTTP_PUT)
                        end

                        if ngx.var.request_method == "POST" and ngx.re.match(path, "^/object/move") then
                            if body.from and body.to then
                                -- Capturar o bucketId da URI original antes do rewrite
                                local bucketId = ngx.re.match(path, "^/object/move/([^/]+)")[1]
                                
                                if bucketId then
                                    -- Monta o novo payload
                                    body = {
                                        bucketId = bucketId,
                                        sourceKey = body.from,
                                        destinationBucket = bucketId,
                                        destinationKey = body.to
                                    }
                                    ngx.log(ngx.INFO, "Payload reorganizado para /object/move: ", cjson.encode(body))
                                    
                                    ngx.req.set_uri("/storage/v1/object/move", false)
                                else
                                    ngx.log(ngx.ERR, "Não foi possível extrair bucketId da URL: ", ngx.var.request_uri)
                                end
                            end
                        end

                        ngx.req.set_body_data(cjson.encode(body))
                    else
                        ngx.log(ngx.ERR, "Falha ao decodificar o corpo da requisição: ", data)
                    end
                end
            }

            header_filter_by_lua_block {
                local path = ngx.var.uri
                if ngx.var.request_method == "POST" and ngx.re.match(path, "/storage/v1/object/sign/") then
                    -- Marca que precisamos processar o corpo da resposta
                    ngx.ctx.process_sign_response = true
                    -- Remove content-length pois vamos alterar o corpo
                    ngx.header.content_length = nil
                end
                
            }

            body_filter_by_lua_block {
                if ngx.ctx.process_sign_response and not ngx.ctx.sign_response_processed then
                    local cjson = require "cjson"
                    local chunk = ngx.arg[1]
                    local eof = ngx.arg[2]
                    
                    ngx.ctx.response_body = (ngx.ctx.response_body or "") .. (chunk or "")
                    
                    if eof then
                        ngx.ctx.sign_response_processed = true
                        local success, response_data = pcall(cjson.decode, ngx.ctx.response_body)
                        
                        if success and response_data and type(response_data) == "table" and #response_data > 0 then
                            local first_item = response_data[1]
                            ngx.log(ngx.ERR, "DEBUG first_item: ", cjson.encode(first_item))
                            if first_item and first_item.signedURL then
                                local server_path = ngx.var.server_path or ""
                                server_path = ngx.re.gsub(server_path, "/$", "", "jo")
                                local signed_url = ngx.re.gsub(first_item.signedURL, "^/", "", "jo")
                                local full_url = server_path .. "/storage/v1/" .. signed_url
                                cjson.encode_escape_forward_slash(false)
                                local result = { signedUrl = full_url }
                                
                                ngx.arg[1] = cjson.encode(result)
                            else
                                ngx.arg[1] = ngx.ctx.response_body
                            end
                        else
                            ngx.log(ngx.ERR, "signedURL is missing or null")
                            ngx.arg[1] = ngx.ctx.response_body
                        end
                    else
                        ngx.arg[1] = nil
                    end
                end
            }
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_set_header X-Forwarded-Scheme $scheme;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-For $remote_addr;
            proxy_set_header X-Real-IP $remote_addr;
            
            proxy_pass $server_path$uri$is_args$args;

            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $http_connection;
            proxy_http_version 1.1;
        }

        location /object/sign {
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_set_header X-Forwarded-Scheme $scheme;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-For $remote_addr;
            proxy_set_header X-Real-IP $remote_addr;
            rewrite ^/object/sign$ /storage/v1/$1 break;
            proxy_pass $server_path$uri$is_args$args;

            # 
            proxy_set_header Connection $http_connection;
            proxy_http_version 1.1;
        }

        location /storage/v1 {
            if ($request_method = OPTIONS) {
                add_header 'Access-Control-Allow-Origin'  '*'        always;
                add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
                add_header 'Access-Control-Allow-Headers' 'Authorization, Content-Type, tus-resumable, upload-length, upload-metadata, x-source' always;
                return 204;
            }
            access_by_lua_block {
                local ref = ngx.var.project_ref
                if not ref or ref == "default" then
                    return
                end
                -- faz fetch da chave (pode abrir socket)
                local get = require "get_service_key"
                local key = get(ref)
                if key and key ~= "" then
                    ngx.req.set_header("Authorization", "Bearer " .. key)
                    ngx.req.set_header("apikey", key)
                end
            }
            rewrite ^/storage/v1/(.*)$ /storage/v1/$1 break;
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_set_header X-Forwarded-Scheme $scheme;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-For $remote_addr;
            proxy_set_header X-Real-IP $remote_addr;

            proxy_pass $server_path$uri$is_args$args;

            # 
            proxy_set_header Connection $http_connection;
            proxy_http_version 1.1;

            add_header 'Access-Control-Allow-Origin'   '*' always;
            add_header 'Access-Control-Allow-Methods'  'GET, POST, PUT, DELETE, OPTIONS' always;
            add_header 'Access-Control-Allow-Headers'  'Authorization, Content-Type, tus-resumable, upload-length, upload-metadata, x-source' always;
        }

        location /api/user/me {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;
            
            set $myrole "";
            set $username "";
            set $display_name "";
            set $user_hash "";
            
            access_by_lua_block {
                local groups = ngx.var.authelia_groups or ""
                local groups_clean = groups:gsub("[%[%]]", "")
                local is_admin = false
                
                -- Verifica se é admin
                for group in groups_clean:gmatch("[^,]+") do
                    if group:match("^%s*admin%s*$") then
                        is_admin = true
                        break
                    end
                end
                
                -- Só permite GET
                if ngx.var.request_method ~= "GET" then
                    return ngx.exit(ngx.HTTP_METHOD_NOT_ALLOWED)
                end
                
                -- Busca dados do usuário no cache pelo hash do email
                local email = ngx.var.authelia_email
                if email and email ~= "" then
                    local resty_sha2 = require "resty.sha256"
                    local str = require "resty.string"
                    
                    -- Normaliza email (lowercase e remove espaços)
                    local normalized_email = email:lower():gsub("%s+", "")
                    
                    -- Gera hash SHA256 do email
                    local hasher = resty_sha2:new()
                    hasher:update(normalized_email)
                    local digest = hasher:final()
                    local hash = str.to_hex(digest)
                    
                    -- Busca no cache
                    local cache = ngx.shared.users_cache
                    local user_data_json = cache:get(hash)
                    
                    if user_data_json then
                        local cjson = require "cjson.safe"
                        local user_data = cjson.decode(user_data_json)
                        
                        if user_data then
                            ngx.var.username = user_data.username or ""
                            ngx.var.display_name = user_data.display_name or ""
                            ngx.var.user_hash = hash
                            
                            ngx.log(ngx.INFO, "[USER_ME] Usuário encontrado no cache: " .. 
                                (user_data.username or "N/A") .. " (" .. normalized_email .. ")")
                        else
                            ngx.log(ngx.WARN, "[USER_ME] Erro ao decodificar dados do usuário do cache")
                        end
                    else
                        ngx.log(ngx.WARN, "[USER_ME] Usuário não encontrado no cache para email: " .. 
                            normalized_email .. " (hash: " .. hash .. ")")
                    end
                else
                    ngx.log(ngx.WARN, "[USER_ME] Email não fornecido pelo Authelia")
                end
                
                ngx.var.myrole = is_admin and "true" or "false"
            }
            
            content_by_lua_block {
                local cjson = require "cjson.safe"
                
                local response = {
                    is_admin = ngx.var.myrole == "true",
                    username = ngx.var.username or "",
                    display_name = ngx.var.display_name or "",
                    user_id = ngx.var.user_hash or ""
                }
                
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode(response))
                
                ngx.log(ngx.INFO, "[USER_ME] Resposta enviada: " .. cjson.encode(response))
            }
        }

        
        location ~ ^/api/admin/users/signup/?$ {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;
            
            access_by_lua_block {
                -- Verificar se é admin
                local groups = ngx.var.authelia_groups or ""
                local groups_clean = groups:gsub("%[", ""):gsub("%]", "")
                local is_admin = false
                for group in groups_clean:gmatch("[^,]+") do
                    if group:match("^%s*admin%s*$") then
                        is_admin = true
                        break
                    end
                end
                
                if not is_admin then
                    ngx.log(ngx.ERR, "[CREATE_USER] Access denied - not admin. Groups: ", groups)
                    ngx.status = ngx.HTTP_FORBIDDEN
                    ngx.say('{"error": "Access denied"}')
                    return ngx.exit(ngx.HTTP_FORBIDDEN)
                end
                
                -- Método deve ser POST para criação
                if ngx.var.request_method ~= "POST" then
                    ngx.status = ngx.HTTP_METHOD_NOT_ALLOWED
                    ngx.say('{"error": "Method not allowed"}')
                    return ngx.exit(ngx.HTTP_METHOD_NOT_ALLOWED)
                end
                
                -- Ler body da requisição
                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                if not body then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error": "Request body is required"}')
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
                
                local cjson = require "cjson.safe"
                local user_data = cjson.decode(body)
                if not user_data then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error": "Invalid JSON format"}')
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
                
                -- Validar campos obrigatórios
                local username = user_data.username
                local password = user_data.password  -- Agora recebe senha em texto plano
                local display_name = user_data.display_name
                local email = user_data.email
                
                if not username or username == "" then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error": "Username is required"}')
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
                
                if not password or password == "" then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error": "Password is required"}')
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
                
                if not display_name or display_name == "" then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error": "Display name is required"}')
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
                
                if not email or email == "" then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error": "Email is required"}')
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
                
                -- Validar formato do email
                local email_pat = "^[%w%._%+%-]+@[%w%._%-]+%.[%a%d]+$"
                if not email:match(email_pat) then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error":"Invalid email format"}')
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
                
                -- Validar tamanho mínimo da senha
                if string.len(password) < 8 then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error": "Password must have at least 8 characters"}')
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
                
                -- FUNÇÃO INTERNA: Gerar hash Argon2 da senha
                local function generate_argon2_hash(plain_password)
                    -- Gerar salt aleatório de 16 bytes (mesmo que Authelia usa)
                    local salt_cmd = "openssl rand -base64 16"
                    local salt_handle = io.popen(salt_cmd)
                    if not salt_handle then
                        ngx.log(ngx.ERR, "[CREATE_USER] Failed to generate salt")
                        return nil
                    end
                    
                    local salt_b64 = salt_handle:read("*a")
                    salt_handle:close()
                    
                    if not salt_b64 or salt_b64 == "" then
                        ngx.log(ngx.ERR, "[CREATE_USER] Empty salt generated")
                        return nil
                    end
                    
                    -- Remover quebras de linha do salt
                    salt_b64 = salt_b64:gsub("%s+", "")
                    
                    -- Escape da senha para uso seguro no shell
                    local escaped_password = plain_password:gsub("'", "'\"'\"'")
                    
                    -- Usar parâmetros exatos do Authelia:
                    -- -t 3: time cost (iterações)
                    -- -m 16: memory cost (65536 KB = 2^16)
                    -- -p 4: parallelism (4 threads)
                    -- -l 32: hash length
                    -- -e: encoded output
                    local cmd = string.format(
                        "printf '%s' | argon2 '%s' -id -t 3 -m 16 -p 4 -l 32 -e",
                        escaped_password,
                        salt_b64
                    )
                    
                    ngx.log(ngx.ERR, "[CREATE_USER] Generating argon2 hash with Authelia parameters")
                    
                    local handle = io.popen(cmd)
                    if not handle then
                        ngx.log(ngx.ERR, "[CREATE_USER] Failed to execute argon2 command")
                        return nil
                    end
                    
                    local output = handle:read("*a")
                    local success, exit_code = handle:close()
                    
                    if not success then
                        ngx.log(ngx.ERR, "[CREATE_USER] Argon2 command failed with exit code: ", tostring(exit_code))
                        return nil
                    end
                    
                    if not output or output == "" then
                        ngx.log(ngx.ERR, "[CREATE_USER] Argon2 command returned empty output")
                        return nil
                    end
                    
                    -- Limpar output (remover quebras de linha)
                    local hash = output:gsub("%s+", "")
                    
                    -- Validar se o hash tem o formato correto e parâmetros do Authelia
                    if not hash:match("^%$argon2id%$v=19%$m=65536,t=3,p=4%$") then
                        ngx.log(ngx.ERR, "[CREATE_USER] Hash format doesn't match Authelia parameters: ", hash)
                        -- Ainda assim retornar o hash se for válido argon2id
                        if not hash:match("^%$argon2id%$") then
                            return nil
                        end
                    end
                    
                    ngx.log(ngx.ERR, "[CREATE_USER] Successfully generated argon2 hash")
                    return hash
                end
                
                -- Gerar hash da senha
                local password_hash = generate_argon2_hash(password)
                if not password_hash then
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Failed to generate password hash"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end
                
                -- Validar se o hash foi gerado corretamente (deve começar com $argon2id$)
                if not password_hash:match("^%$argon2id%$") then
                    ngx.log(ngx.ERR, "[CREATE_USER] Invalid hash format generated: ", password_hash)
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Invalid password hash generated"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end
                
                -- Ler arquivo YAML
                local lyaml = require "lyaml"
                local yaml_path = "/config/users_database.yml"
                local f, err = io.open(yaml_path, "r")
                if not f then
                    ngx.log(ngx.ERR, "[CREATE_USER] Failed to open YAML: ", err)
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Failed to read user database"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end

                local content = f:read("*a")
                f:close()

                local yaml_data = lyaml.load(content)
                if not yaml_data or not yaml_data.users then
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Invalid YAML structure"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end

                -- Verificar se username já existe (case-insensitive)
                local username_lower = username:lower()
                for existing_user, _ in pairs(yaml_data.users) do
                    if existing_user:lower() == username_lower then
                        ngx.status = ngx.HTTP_CONFLICT
                        ngx.say('{"error": "Username already exists"}')
                        return ngx.exit(ngx.HTTP_CONFLICT)
                    end
                end
                
                -- Verificar se email já existe
                local email_lower = email:lower()
                for _, user_info in pairs(yaml_data.users) do
                    if user_info.email and user_info.email:lower() == email_lower then
                        ngx.status = ngx.HTTP_CONFLICT
                        ngx.say('{"error": "Email already exists"}')
                        return ngx.exit(ngx.HTTP_CONFLICT)
                    end
                end
                local function build_authelia_user(password_hash, email, display_name, is_admin)
                    -- `lyaml.null` força o '~' em YAML
                    return {
                        middle_name    = '',
                        email          = email,
                        groups         = {"active"},
                        family_name    = '',
                        nickname       = '',
                        gender         = '',
                        birthdate      = '',
                        website        = '',
                        profile        = '',
                        picture        = '',
                        zoneinfo       = '',
                        locale         = '',
                        phone_number   = '',
                        phone_extension= '',
                        disabled       = false,          -- boolean, não string
                        password       = password_hash,  -- hash Argon2id
                        -- extra          = lyaml.null,             -- tabela vazia → `{}` no YAML
                        extra = {
                              created_at = "ts:" .. os.date("!%Y-%m-%dT%H:%M:%SZ")
                        },
                        given_name     = '',
                        displayname    = display_name,
                        address        = lyaml.null      -- gera "~" (null) no YAML
                    }
                end

                local new_user_record = build_authelia_user(
                    password_hash,
                    email,
                    display_name                     
                )
                -- Criar novo usuário
                yaml_data.users[username] = new_user_record

                -- Serializar e salvar YAML
                local updated_yaml = lyaml.dump({ yaml_data })

                local f_write, err_write = io.open(yaml_path, "w")
                if not f_write then
                    ngx.log(ngx.ERR, "[CREATE_USER] Failed to write YAML: ", err_write)
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Failed to update user database"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end
                f_write:write(updated_yaml)
                f_write:close()
                
                -- Gerar ID para cache (hash do username)
                local user_id = ngx.md5(username:lower())
                
                -- Adicionar ao cache
                local cache = ngx.shared.users_cache
                local cache_user = {
                    username = username,
                    display_name = display_name,
                    email = email,
                    is_active = true
                }
                cache:set(user_id, cjson.encode(cache_user))
                
                ngx.log(ngx.ERR, "[CREATE_USER] Successfully created user: ", username)
                
                -- Resposta de sucesso
                ngx.status = ngx.HTTP_CREATED
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode({
                    message = "User created successfully",
                    user = {
                        id = user_id,
                        username = username,
                        display_name = display_name,
                        email = email,
                        status = "active"
                    },
                    timestamp = os.time()
                }))
                return 
            }
        }

        location /api/admin/users {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;
            
            access_by_lua_block {
                -- Verificar se é admin
                local groups = ngx.var.authelia_groups or ""
                local groups_clean = groups:gsub("[%[%]]", "")
                local is_admin = false
                for group in groups_clean:gmatch("[^,]+") do
                    if group:match("^%s*admin%s*$") then
                        is_admin = true
                        break
                    end
                end
                
                if not is_admin then
                    ngx.log(ngx.ERR, "[ADMIN-USERS] Access denied - not admin. Groups: ", groups)
                    return ngx.exit(ngx.HTTP_FORBIDDEN)
                end
                
                -- Só permite GET
                if ngx.var.request_method ~= "GET" then
                    return ngx.exit(ngx.HTTP_METHOD_NOT_ALLOWED)
                end
            }
            
            content_by_lua_block {
                local cjson = require "cjson.safe"
                local cache = ngx.shared.users_cache
                local keys, err = cache:get_keys(0)
                
                if not keys then
                    ngx.log(ngx.ERR, "[ADMIN-USERS] cache:get_keys error: ", err)
                    ngx.say('{"error": "Failed to fetch users"}')
                    return ngx.exit(500)
                end
                
                local users = {}
                local active_count = 0
                local inactive_count = 0
                
                for _, key in ipairs(keys) do
                    if key ~= "__mtime" then
                        local user_data = cache:get(key)
                        if user_data then
                            local user = cjson.decode(user_data)
                            if user then
                                -- EXCLUIR ADMINS DOS RESULTADOS
                                if not user.is_admin then
                                    -- DADOS SEGUROS PARA O FRONTEND
                                    local safe_user = {
                                        id = key,  -- hash do email (identificador único)
                                        username = user.username,
                                        display_name = user.display_name,
                                        is_active = user.is_active,
                                        status = user.is_active and "active" or "inactive",
                                        -- Primeira letra do email + domínio mascarado
                                        email_hint = user.email and (
                                            user.email:sub(1,1) .. "***@" .. 
                                            user.email:match("@(.+)$"):gsub("^(.)", "%1***")
                                        ) or "unknown"
                                    }
                                    
                                    table.insert(users, safe_user)
                                    
                                    if user.is_active then
                                        active_count = active_count + 1
                                    else
                                        inactive_count = inactive_count + 1
                                    end
                                end
                            end
                        end
                    end
                end
                
                -- Ordenar: ativos primeiro, depois por username
                table.sort(users, function(a, b)
                    if a.is_active ~= b.is_active then
                        return a.is_active  -- ativos primeiro
                    end
                    return a.username < b.username
                end)
                
                local response = {
                    users = users,
                    summary = {
                        total = #users,
                        active = active_count,
                        inactive = inactive_count
                    },
                    timestamp = os.time()
                }
                
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode(response))
            }
        }

        location ~ ^/api/admin/users/([^/]+)/deactivate/?$ {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;
            
            access_by_lua_block {
                -- Verificar se é admin
                local groups = ngx.var.authelia_groups or ""
                local groups_clean = groups:gsub("[%[%]]", "")
                local is_admin = false
                for group in groups_clean:gmatch("[^,]+") do
                    if group:match("^%s*admin%s*$") then
                        is_admin = true
                        break
                    end
                end
                
                if not is_admin then
                    ngx.log(ngx.ERR, "[DEACTIVATE] Access denied - not admin. Groups: ", groups)
                    ngx.status = ngx.HTTP_FORBIDDEN
                    ngx.say('{"error": "Access denied"}')
                    return ngx.exit(ngx.HTTP_FORBIDDEN)
                end
                
                -- Método deve ser POST
                if ngx.var.request_method ~= "POST" then
                    ngx.status = ngx.HTTP_METHOD_NOT_ALLOWED
                    ngx.say('{"error": "Method not allowed"}')
                    return ngx.exit(ngx.HTTP_METHOD_NOT_ALLOWED)
                end
                
                local user_id = ngx.var[1]
                if not user_id or user_id == "" then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error": "User ID is required"}')
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
                
                -- Verificar se usuário existe no cache
                local cache = ngx.shared.users_cache
                local user_data = cache:get(user_id)
                if not user_data then
                    ngx.status = ngx.HTTP_NOT_FOUND
                    ngx.say('{"error": "User not found"}')
                    return ngx.exit(ngx.HTTP_NOT_FOUND)
                end
                
                local cjson = require "cjson.safe"
                local user = cjson.decode(user_data)
                if not user then
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Invalid user data"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end
                
                local username = user.username
                
                -- Ler e processar YAML
                local lyaml = require "lyaml"
                local yaml_path = "/config/users_database.yml"
                local f, err = io.open(yaml_path, "r")
                if not f then
                    ngx.log(ngx.ERR, "[DEACTIVATE] Failed to open YAML: ", err)
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Failed to read user database"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end

                local content = f:read("*a")
                f:close()

                local yaml_data = lyaml.load(content)
                if not yaml_data or not yaml_data.users then
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Invalid YAML structure"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end

                local user_entry = yaml_data.users[username]
                if not user_entry then
                    ngx.log(ngx.ERR, "[DEACTIVATE] User not found in YAML: ", username)
                    ngx.status = ngx.HTTP_NOT_FOUND
                    ngx.say('{"error": "User not found in database"}')
                    return ngx.exit(ngx.HTTP_NOT_FOUND)
                end

                do
                    local sha2 = require "resty.sha256"
                    local str  = require "resty.string"
                    local h    = sha2:new()
                    h:update((ngx.var.authelia_email or ""):lower():gsub("%s+", ""))
                    local caller_id = str.to_hex(h:final())

                    local target_is_me    = (caller_id == user_id)

                    local target_is_admin = false
                    for _, g in ipairs(user_entry.groups or {}) do
                        if g == "admin" then
                        target_is_admin = true
                        break
                        end
                    end

                    if target_is_me then
                        ngx.status = ngx.HTTP_FORBIDDEN
                        ngx.say('{"error":"You cannot deactivate yourself"}')
                        return ngx.exit(ngx.HTTP_FORBIDDEN)
                    end

                    if target_is_admin then
                        ngx.status = ngx.HTTP_FORBIDDEN
                        ngx.say('{"error":"Cannot deactivate an admin user"}')
                        return ngx.exit(ngx.HTTP_FORBIDDEN)
                    end
                end
                -- Verificar se usuário já está inativo
                if user_entry.groups then
                    local has_inactive = false
                    for _, g in ipairs(user_entry.groups) do
                        if g == "inactive" then
                            has_inactive = true
                            break
                        end
                    end
                    if has_inactive then
                        ngx.status = ngx.HTTP_OK
                        ngx.say('{"message": "User is already inactive"}')
                        return ngx.exit(ngx.HTTP_OK)
                    end
                end

                -- Substituir 'active' por 'inactive'
                user_entry.groups = user_entry.groups or {}
                local new_groups = {}
                for _, g in ipairs(user_entry.groups) do
                    if g ~= "active" then
                        table.insert(new_groups, g)
                    end
                end
                table.insert(new_groups, "inactive")
                user_entry.groups = new_groups


                -- Salvar YAML
                local updated_yaml = lyaml.dump({ yaml_data })
                local f_write, err_write = io.open(yaml_path, "w")
                if not f_write then
                    ngx.log(ngx.ERR, "[DEACTIVATE] Failed to write YAML: ", err_write)
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Failed to update user database"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end
                f_write:write(updated_yaml)
                f_write:close()

                -- Atualizar cache
                user.is_active = false
                cache:set(user_id, cjson.encode(user))

                ngx.log(ngx.ERR, "[DEACTIVATE] Successfully deactivated user: ", username)
                
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode({
                    message = "User deactivated successfully",
                    user = {
                        id = user_id,
                        username = username,
                        display_name = user.display_name,
                        status = "deactivated"
                    },
                    timestamp = os.time()
                }))
                return ngx.exit(ngx.HTTP_OK)
            }
        }

        location ~ ^/api/admin/users/([^/]+)/activate/?$ {
            auth_request_set $authelia_email   $upstream_http_remote_email;
            auth_request_set $authelia_groups  $upstream_http_remote_groups;
            
            access_by_lua_block {
                -- Verificar se é admin
                local groups = ngx.var.authelia_groups or ""
                local groups_clean = groups:gsub("[%[%]]", "")
                local is_admin = false
                for group in groups_clean:gmatch("[^,]+") do
                    if group:match("^%s*admin%s*$") then
                        is_admin = true
                        break
                    end
                end
                
                if not is_admin then
                    ngx.log(ngx.ERR, "[ACTIVATE] Access denied - not admin. Groups: ", groups)
                    ngx.status = ngx.HTTP_FORBIDDEN
                    ngx.say('{"error": "Access denied"}')
                    return ngx.exit(ngx.HTTP_FORBIDDEN)
                end
                
                -- Método deve ser POST
                if ngx.var.request_method ~= "POST" then
                    ngx.status = ngx.HTTP_METHOD_NOT_ALLOWED
                    ngx.say('{"error": "Method not allowed"}')
                    return ngx.exit(ngx.HTTP_METHOD_NOT_ALLOWED)
                end
                
                local user_id = ngx.var[1]
                if not user_id or user_id == "" then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error": "User ID is required"}')
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
                
                -- Verificar se usuário existe no cache
                local cache = ngx.shared.users_cache
                local user_data = cache:get(user_id)
                if not user_data then
                    ngx.status = ngx.HTTP_NOT_FOUND
                    ngx.say('{"error": "User not found"}')
                    return ngx.exit(ngx.HTTP_NOT_FOUND)
                end
                
                local cjson = require "cjson.safe"
                local user = cjson.decode(user_data)
                if not user then
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Invalid user data"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end
                
                local username = user.username
                
                -- Ler e processar YAML
                local lyaml = require "lyaml"
                local yaml_path = "/config/users_database.yml"
                local f, err = io.open(yaml_path, "r")
                if not f then
                    ngx.log(ngx.ERR, "[ACTIVATE] Failed to open YAML: ", err)
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Failed to read user database"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end

                local content = f:read("*a")
                f:close()

                local yaml_data = lyaml.load(content)
                if not yaml_data or not yaml_data.users then
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Invalid YAML structure"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end

                local user_entry = yaml_data.users[username]
                if not user_entry then
                    ngx.log(ngx.ERR, "[ACTIVATE] User not found in YAML: ", username)
                    ngx.status = ngx.HTTP_NOT_FOUND
                    ngx.say('{"error": "User not found in database"}')
                    return ngx.exit(ngx.HTTP_NOT_FOUND)
                end

                -- Verificar se usuário já está ativo
                if user_entry.groups then
                    local has_active = false
                    for _, g in ipairs(user_entry.groups) do
                        if g == "active" then
                            has_active = true
                            break
                        end
                    end
                    if has_active then
                        ngx.status = ngx.HTTP_OK
                        ngx.say('{"message": "User is already active"}')
                        return ngx.exit(ngx.HTTP_OK)
                    end
                end

                -- Substituir 'inactive' por 'active'
                user_entry.groups = user_entry.groups or {}
                local new_groups = {}
                for _, g in ipairs(user_entry.groups) do
                    if g ~= "inactive" then
                        table.insert(new_groups, g)
                    end
                end
                table.insert(new_groups, "active")
                user_entry.groups = new_groups

                -- Salvar YAML
                local updated_yaml = lyaml.dump({ yaml_data })
                local f_write, err_write = io.open(yaml_path, "w")
                if not f_write then
                    ngx.log(ngx.ERR, "[ACTIVATE] Failed to write YAML: ", err_write)
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error": "Failed to update user database"}')
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end
                f_write:write(updated_yaml)
                f_write:close()

                -- Atualizar cache
                user.is_active = true
                cache:set(user_id, cjson.encode(user))

                ngx.log(ngx.ERR, "[ACTIVATE] Successfully activated user: ", username)

                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode({
                    message = "User activated successfully",
                    user = {
                        id = user_id,
                        username = username,
                        display_name = user.display_name,
                        status = "active"
                    },
                    timestamp = os.time()
                }))
                return ngx.exit(ngx.HTTP_OK)
            }
        }

        location = /api/admin/projects-info {
            auth_request_set $authelia_email $upstream_http_remote_email;
            auth_request_set $authelia_groups $upstream_http_remote_groups;

            access_by_lua_block {
                local groups = ngx.var.authelia_groups or ""
                local groups_clean = groups:gsub("[%[%]]", "")
                local is_admin = false

                for group in groups_clean:gmatch("[^,]+") do
                    if group:match("^%s*admin%s*$") then
                        is_admin = true
                        break
                    end
                end

                if not is_admin then
                    ngx.log(ngx.ERR, "[ADMIN_PROJECTS_INFO] Access denied - not admin. Groups: ", groups)
                    ngx.status = ngx.HTTP_FORBIDDEN
                    ngx.say('{"error": "Access denied"}')
                    return ngx.exit(ngx.HTTP_FORBIDDEN)
                end

                -- Só permite POST
                if ngx.var.request_method ~= "POST" then
                    ngx.status = ngx.HTTP_METHOD_NOT_ALLOWED
                    ngx.say('{"error": "Método não permitido"}')
                    return ngx.exit(ngx.HTTP_METHOD_NOT_ALLOWED)
                end
            }

            proxy_pass $server_domain/api/projects/admin/projects-info;
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Remote-Email $authelia_email;
            proxy_set_header Remote-Groups $authelia_groups;
        }

        
        location ~ ^/api/admin/projects/([^/]+)/?$ {
            auth_request_set $authelia_email $upstream_http_remote_email;
            auth_request_set $authelia_groups $upstream_http_remote_groups;
            
            access_by_lua_block {
                -- Verificar se é admin
                local groups = ngx.var.authelia_groups or ""
                local groups_clean = groups:gsub("%[", ""):gsub("%]", "")
                local is_admin = false
                
                for group in groups_clean:gmatch("[^,]+") do
                    if group:match("^%s*admin%s*$") then
                        is_admin = true
                        break
                    end
                end
                
                if not is_admin then
                    ngx.log(ngx.ERR, "[DELETE_PROJECT] Access denied - not admin. Groups: ", groups)
                    ngx.status = ngx.HTTP_FORBIDDEN
                    ngx.say('{"error": "Access denied - admin required"}')
                    return ngx.exit(ngx.HTTP_FORBIDDEN)
                end
                
                -- Método deve ser DELETE para exclusão
                if ngx.var.request_method ~= "DELETE" then
                    ngx.status = ngx.HTTP_METHOD_NOT_ALLOWED
                    ngx.say('{"error": "Method not allowed - use DELETE"}')
                    return ngx.exit(ngx.HTTP_METHOD_NOT_ALLOWED)
                end
                
                -- Verificar se o header X-Delete-Password está presente
                local delete_password = ngx.var.http_x_delete_password
                if not delete_password or delete_password == "" then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error": "X-Delete-Password header is required"}')
                    return ngx.exit(ngx.HTTP_BAD_REQUEST)
                end
                
                ngx.log(ngx.INFO, "[DELETE_PROJECT] Admin access granted for user: ", ngx.var.authelia_email)
            }
            
            proxy_pass $server_domain/api/projects/$1;
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Remote-Email $authelia_email;
            proxy_set_header Remote-Groups $authelia_groups;
        }

        location ~ ^/api/admin/projects/(?<slug>[^/]+)/all-users$ {
            auth_request_set $authelia_email $upstream_http_remote_email;
            auth_request_set $authelia_groups $upstream_http_remote_groups;
            
            access_by_lua_block {
                local email = ngx.var.authelia_email
                local groups = ngx.var.authelia_groups or ""
                
                if not email or email == "" then
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
                
                -- Verificar se é admin (ajuste conforme sua lógica)
                local is_admin = string.find(groups, "admin") ~= nil
                if not is_admin then
                    ngx.log(ngx.ERR, "[ALL-USERS] User not admin: ", email, " groups: ", groups)
                    return ngx.exit(ngx.HTTP_FORBIDDEN)
                end
                
                -- Hash do email
                local sha256 = require "resty.sha256"
                local str = require "resty.string"
                local hasher = sha256:new()
                hasher:update(email)
                local digest = hasher:final()
                local email_hash = str.to_hex(digest)
                
                ngx.req.set_header("Remote-Email", email_hash)
                ngx.req.set_header("Remote-Groups", groups)
            }
            
            content_by_lua_block {
                local cjson = require "cjson.safe"
                local slug = ngx.var.slug
                
                if not slug or slug == "" then
                    ngx.log(ngx.ERR, "[ALL-USERS] Slug inválido")
                    return ngx.exit(400)
                end
                
                -- FONTE 1: Buscar membros atuais do projeto (API Python)
                local members_res = ngx.location.capture("/_internal_api/projects/" .. slug .. "/members")
                local current_members = {}
                local member_lookup = {}
                local admin_users = {} -- Track de usuários que já são admin
                
                if members_res.status == 200 then
                    current_members = cjson.decode(members_res.body) or {}
                    for _, m in ipairs(current_members) do
                        if m.user_id then
                            member_lookup[m.user_id] = {
                                role = m.role,
                                is_member = true
                            }
                            
                            -- Marcar usuários que já são admin
                            if m.role == "admin" then
                                admin_users[m.user_id] = true
                            end
                        end
                    end
                    ngx.log(ngx.ERR, "[ALL-USERS] Found ", #current_members, " current members")
                else
                    ngx.log(ngx.ERR, "[ALL-USERS] Failed to fetch members, status: ", members_res.status)
                end
                
                -- FONTE 2: Buscar todos os usuários do cache (Nginx)
                local cache = ngx.shared.users_cache
                local keys, err = cache:get_keys(0)
                if not keys then
                    ngx.log(ngx.ERR, "[ALL-USERS] cache:get_keys error: ", err)
                    return ngx.exit(500)
                end
                
                ngx.log(ngx.ERR, "[ALL-USERS] Cache has ", #keys, " user keys")
                
                -- COMBINAR: Criar lista de usuários disponíveis para transferência
                local all_users = {}
                local users_found = 0
                local members_found = 0
                local available_found = 0
                local admins_excluded = 0
                
                for _, user_hash in ipairs(keys) do
                    if user_hash ~= "__mtime" then
                        local user_json = cache:get(user_hash)
                        if user_json then
                            local user_data = cjson.decode(user_json)
                            
                            if user_data then
                                users_found = users_found + 1
                                
                                -- LÓGICA DE FILTRAGEM:
                                -- Incluir APENAS se:
                                -- 1. NÃO é membro do projeto (disponível para entrar)
                                -- 2. É membro mas NÃO é admin (pode virar admin)
                                local is_current_admin = admin_users[user_hash] == true
                                
                                if not is_current_admin then
                                    local user_info = {
                                        user_id = user_hash,
                                        display_name = user_data.display_name or "Unknown",
                                        username = user_data.username or "unknown",
                                        is_active = user_data.is_active or false,
                                        status = "available"
                                    }
                                    
                                    -- Se é membro atual (mas não admin), enriquecer com dados do projeto
                                    if member_lookup[user_hash] then
                                        user_info.status = "member"
                                        user_info.project_role = member_lookup[user_hash].role
                                        members_found = members_found + 1
                                        ngx.log(ngx.ERR, "[ALL-USERS] Including non-admin member: ", user_data.display_name, " role: ", member_lookup[user_hash].role)
                                    else
                                        available_found = available_found + 1
                                        ngx.log(ngx.ERR, "[ALL-USERS] Including available user: ", user_data.display_name)
                                    end
                                    
                                    table.insert(all_users, user_info)
                                end
                            end
                        end
                    end
                end
                
                -- Verificar se existem membros no banco que não estão no cache
                -- (excluindo admins)
                local orphaned_members = {}
                for _, member in ipairs(current_members) do
                    local is_admin = (member.role == "admin")
                    
                    if not is_admin then -- Só processar não-admins
                        local found_in_cache = false
                        for _, user in ipairs(all_users) do
                            if user.user_id == member.user_id then
                                found_in_cache = true
                                break
                            end
                        end
                        
                        if not found_in_cache then
                            table.insert(orphaned_members, {
                                user_id = member.user_id,
                                display_name = "Unknown User",
                                username = "unknown",
                                is_active = false,
                                status = "member",
                                project_role = member.role,
                                note = "User not found in cache"
                            })
                        end
                    end
                end
                
                -- Adicionar membros órfãos à lista
                for _, orphan in ipairs(orphaned_members) do
                    table.insert(all_users, orphan)
                end
                
                -- Ordenar por status (membros primeiro) e depois por display_name
                table.sort(all_users, function(a, b)
                    if a.status ~= b.status then
                        return a.status == "member"
                    end
                    return (a.display_name or "") < (b.display_name or "")
                end)
                
                -- Resposta estruturada
                local response = {
                    project_slug = slug,
                    summary = {
                        total_users = #all_users,
                        current_members = members_found, -- Membros não-admin incluídos
                        available_users = available_found, -- Usuários disponíveis
                        orphaned_members = #orphaned_members,
                        cache_keys = #keys - 1
                    },
                    users = all_users
                }
                
                ngx.log(ngx.ERR, "[ALL-USERS] Response summary: ", cjson.encode(response.summary))
                
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode(response))
            }
        }


        location ~ ^/api/admin/projects/([^/]+)/transfer/?$ {
            auth_request_set $authelia_email  $upstream_http_remote_email;
            auth_request_set $authelia_groups $upstream_http_remote_groups;

            access_by_lua_block {
                local groups = ngx.var.authelia_groups or ""
                local groups_clean = groups:gsub("[%[%]]", "")
                local is_admin = false
                for g in groups_clean:gmatch("[^,]+") do
                    if g:match("^%s*admin%s*$") then
                        is_admin = true
                        break
                    end
                end

                if not is_admin then
                    ngx.status = ngx.HTTP_FORBIDDEN
                    ngx.say('{"error":"Access denied – admin required"}')
                    return ngx.exit(ngx.HTTP_FORBIDDEN)
                end

                if ngx.var.request_method ~= "POST" then   -- <- transferência é POST
                    ngx.status = ngx.HTTP_METHOD_NOT_ALLOWED
                    ngx.say('{"error":"Method not allowed – use POST"}')
                    return ngx.exit(ngx.HTTP_METHOD_NOT_ALLOWED)
                end
            }

            proxy_pass          $server_domain/api/projects/$1/transfer;
            proxy_ssl_server_name on;
            proxy_ssl_name        $server_hostname;   
            proxy_set_header      Host $server_hostname;
            proxy_set_header    X-Real-IP           $remote_addr;
            proxy_set_header    X-Forwarded-For     $proxy_add_x_forwarded_for;
            proxy_set_header    X-Forwarded-Proto   $scheme;
            proxy_set_header    Remote-Email        $authelia_email;
            proxy_set_header    Remote-Groups       $authelia_groups;
        }
    }
}
